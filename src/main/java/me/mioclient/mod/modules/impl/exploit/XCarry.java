
package me.mioclient.mod.modules.impl.exploit;

import me.mioclient.api.events.impl.ClientEvent;
import me.mioclient.api.events.impl.PacketEvent;
import me.mioclient.api.util.math.ReflectionUtil;
import me.mioclient.api.util.world.InventoryUtil;
import me.mioclient.mod.commands.Command;
import me.mioclient.mod.gui.screen.MioClickGui;
import me.mioclient.mod.modules.Category;
import me.mioclient.mod.modules.Module;
import me.mioclient.mod.modules.settings.Bind;
import me.mioclient.mod.modules.settings.Setting;
import net.minecraft.client.gui.inventory.GuiInventory;
import net.minecraft.inventory.Slot;
import net.minecraft.network.play.client.CPacketCloseWindow;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.InputEvent;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;

public class XCarry extends Module {

    private static XCarry INSTANCE = new XCarry();

    private final Setting<Boolean> simpleMode =
            add(new Setting<>("Simple", false));
    
    private final Setting<Bind> autoDuel =
            add(new Setting<>("AutoDuel", new Bind(-1)));
    private final Setting<Integer> obbySlot =
            add(new Setting<>("ObbySlot", 2, 1, 9, v -> autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> slot1 =
            add(new Setting<>("Slot1", 22, 9, 44, v -> autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> slot2 =
            add(new Setting<>("Slot2", 23, 9, 44, v -> autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> slot3 =
            add(new Setting<>("Slot3", 24, 9, 44, v -> autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> tasks =
            add(new Setting<>("Actions", 3, 1, 12, v -> autoDuel.getValue().getKey() != -1));

    private final Setting<Boolean> shiftClicker =
            add(new Setting<>("ShiftClick", false).setParent());
    private final Setting<Boolean> withShift =
            add(new Setting<>("WithShift", true, v -> shiftClicker.isOpen()));
    private final Setting<Bind> keyBind =
            add(new Setting<>("ShiftBind", new Bind(-1), v -> shiftClicker.isOpen()));
    
    private final AtomicBoolean shouldCloseGui = new AtomicBoolean(false);
    private final Queue<InventoryUtil.QueuedTask> queuedTaskList = new ConcurrentLinkedQueue<>();

    private GuiInventory openedGui;

    private boolean guiCloseGuard;
    private boolean autoDuelOn;
    private boolean obbySlotDone;
    private boolean slot1done;
    private boolean slot2done;
    private boolean slot3done;
    
    private List<Integer> doneSlots = new ArrayList<>();

    public XCarry() {
        super("XCarry", "Uses the crafting inventory for storage", Category.EXPLOIT, true);
        setInstance();
    }

    private void setInstance() {
        INSTANCE = this;
    }

    public static XCarry getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new XCarry();
        }
        return INSTANCE;
    }

    @Override
    public void onDisable() {
        if (!fullNullCheck()) {
            if (!simpleMode.getValue()) {
                closeGui();
                close();
            } else {
                mc.player.connection.sendPacket(new CPacketCloseWindow(mc.player.inventoryContainer.windowId));
            }
        }
    }

    @Override
    public void onLogout() {
        onDisable();
    }

    @Override
    public void onUpdate() {
        if (shiftClicker.getValue() && mc.currentScreen instanceof GuiInventory) {

            Slot slot;
            boolean ourBind = keyBind.getValue().getKey() != -1 && Keyboard.isKeyDown(keyBind.getValue().getKey()) && !Keyboard.isKeyDown(42);

            if ((Keyboard.isKeyDown(42) && withShift.getValue() || ourBind)
                    && Mouse.isButtonDown(0)
                    && (slot = ((GuiInventory) mc.currentScreen).getSlotUnderMouse()) != null
                    && InventoryUtil.getEmptyXCarry() != -1) {

                int slotNumber = slot.slotNumber;

                if (slotNumber > 4 && ourBind) {
                    queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                    queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));

                } else if (slotNumber > 4 && withShift.getValue()) {

                    boolean isHotBarFull = true;
                    boolean isInvFull = true;

                    for (int i : InventoryUtil.findEmptySlots(false)) {
                        if (i > 4 && i < 36) {
                            isInvFull = false;
                            continue;
                        }

                        if (i <= 35 || i >= 45) continue;

                        isHotBarFull = false;
                    }

                    if (slotNumber > 35 && slotNumber < 45) {

                        if (isInvFull) {
                            queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                            queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                        }

                    } else if (isHotBarFull) {
                        queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                        queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                    }
                }
            }
        }
        
        if (autoDuelOn) {

            doneSlots = new ArrayList<>();
            
            if (InventoryUtil.getEmptyXCarry() == -1 || obbySlotDone && slot1done && slot2done && slot3done) {
                autoDuelOn = false;
            }
            if (autoDuelOn) {

                if (!obbySlotDone && !mc.player.inventory.getStackInSlot((obbySlot.getValue() - 1)).isEmpty) {
                    addTasks(36 + obbySlot.getValue() - 1);
                }
                obbySlotDone = true;

                if (!slot1done && !(mc.player.inventoryContainer.inventorySlots.get(slot1.getValue())).getStack().isEmpty) {
                    addTasks(slot1.getValue());
                }
                slot1done = true;

                if (!slot2done && !(mc.player.inventoryContainer.inventorySlots.get(slot2.getValue())).getStack().isEmpty) {
                    addTasks(slot2.getValue());
                }
                slot2done = true;

                if (!slot3done && !(mc.player.inventoryContainer.inventorySlots.get(slot3.getValue())).getStack().isEmpty) {
                    addTasks(slot3.getValue());
                }
                slot3done = true;
            }

        } else {
            obbySlotDone = false;
            slot1done = false;
            slot2done = false;
            slot3done = false;
        }

        if (!queuedTaskList.isEmpty()) {

            for (int i = 0; i < tasks.getValue(); ++i) {
                InventoryUtil.QueuedTask queuedTask = queuedTaskList.poll();

                if (queuedTask == null) continue;

                queuedTask.run();
            }
        }
    }

    @SubscribeEvent(priority=EventPriority.LOWEST)
    public void onGuiOpen(GuiOpenEvent event) {
        if (!simpleMode.getValue()) {

            if (guiCloseGuard) {
                event.setCanceled(true);

            } else if (event.getGui() instanceof GuiInventory) {
                openedGui = createGuiWrapper((GuiInventory)event.getGui());
                event.setGui(openedGui);
                shouldCloseGui.set(false);
            }
        }
    }

    @SubscribeEvent
    public void onGuiClose(PacketEvent.Send event) {
        if (simpleMode.getValue() && event.getPacket() instanceof CPacketCloseWindow) {

            CPacketCloseWindow packet = event.getPacket();

            if (packet.windowId == mc.player.inventoryContainer.windowId) {
                event.cancel();
            }
        }
    }

    @SubscribeEvent
    public void onSettingChange(ClientEvent event) {
        if (event.getStage() == 2 && event.getSetting() != null && event.getSetting().getMod() != null && event.getSetting().getMod().equals(this)) {

            Setting setting = event.getSetting();
            String settingname = event.getSetting().getName();

            if (setting.equals(simpleMode) && setting.getPlannedValue() != setting.getValue()) {
                disable();

            } else if (settingname.equalsIgnoreCase("Store")) {
                event.cancel();
                autoDuelOn = !autoDuelOn;
                Command.sendMessage("<XCarry> \u00a7aAutostoring...");
            }
        }
    }

    @SubscribeEvent
    public void onKeyInput(InputEvent.KeyInputEvent event) {
        if (Keyboard.getEventKeyState() && !(mc.currentScreen instanceof MioClickGui) && autoDuel.getValue().getKey() == Keyboard.getEventKey()) {
            autoDuelOn = !autoDuelOn;
            Command.sendMessage("<XCarry> \u00a7aAutostoring...");
        }
    }

    private void addTasks(int slot) {
        if (InventoryUtil.getEmptyXCarry() != -1) {

            int xcarrySlot = InventoryUtil.getEmptyXCarry();

            if (!(!doneSlots.contains(xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot) || !doneSlots.contains(++xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot) || !doneSlots.contains(++xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot) || !doneSlots.contains(++xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot))) {
                return;

            }
            if (xcarrySlot > 4) {
                return;
            }

            doneSlots.add(xcarrySlot);
            queuedTaskList.add(new InventoryUtil.QueuedTask(slot));
            queuedTaskList.add(new InventoryUtil.QueuedTask(xcarrySlot));
            queuedTaskList.add(new InventoryUtil.QueuedTask());
        }
    }

    private void close() {
        openedGui = null;
        shouldCloseGui.set(false);
        guiCloseGuard = false;
    }

    private void closeGui() {
        if (shouldCloseGui.compareAndSet(true, false) && !fullNullCheck()) {
            guiCloseGuard = true;
            mc.player.closeScreen();

            if (openedGui != null) {
                openedGui.onGuiClosed();
                openedGui = null;
            }

            guiCloseGuard = false;
        }
    }

    private GuiInventory createGuiWrapper(GuiInventory gui) {
        try {
            GuiInventoryWrapper wrapper = new GuiInventoryWrapper();
            ReflectionUtil.copyOf(gui, wrapper);
            return wrapper;
        }
        catch (IllegalAccessException | NoSuchFieldException e) {
            e.printStackTrace();
            return null;
        }
    }

    private class GuiInventoryWrapper extends GuiInventory {

        GuiInventoryWrapper() {
            super(XCarry.this.mc.player);
        }

        protected void keyTyped(char typedChar, int keyCode) throws IOException {
            if (isOn() && (keyCode == 1 || mc.gameSettings.keyBindInventory.isActiveAndMatches(keyCode))) {
                shouldCloseGui.set(true);
                mc.displayGuiScreen(null);
            } else {
                super.keyTyped(typedChar, keyCode);
            }
        }

        public void onGuiClosed() {
            if (guiCloseGuard || !isOn()) {
                super.onGuiClosed();
            }
        }
    }
}

